# 同步调用和异步调用

## 同步调用
```c++
funcA(){
	funcB();
// wait for funcB finishd;
}
```
当执行完funcB之后才能继续执行funcA,即所谓的同步调用
- 需要注意的是，即使在不同的线程中,也可能是同步的调用,比如
```c++
funcC(){
read(file,buf)
}
```
其中read(file,buf)调用的是kernel的读写线程，与主调函数不在一个线程中，所以同步与否看的是，主调函数和被调函数是否可以同步执行,而不是是否在同一个线程中

## 异步调用
```C++
read(file,buff);
//如果是异步调用，直接返回，执行接下来的程序中，不会阻塞当前程序中
```
一般用在除了磁盘读写、网络数据收发、数据库操作中,异步调用如何确定被调函数是否执行完成
- 调用函数不需要知道调用结果，只执行被调函数即可
- 调用方需要知道调用结果
	- 信号，如linux signal
	- 回调函数，callback()

## 同步vs异步

假设WebServer接受用户请求后会有一些典型的处理逻辑，最典型的就是数据库查询，假定步骤是 `ABC数据库查询DEF`
```c++
A;
B;
C;
数据库读取;
D;
E;
F;
```
A,B,C,D,E,F不需要任何I/O操作

如果是同步的方式，很直观：
```C++
main_thread(){
		A;
		B;
		C;
		//send request
		D;
		E;
		F;
}
//database thread
DataBase_thread(){
while(1){
	//handle request;
	return;
	}
}
```
这是最典型的同步方法，主线程因为send request处理后才能继续执行DEF,直到数据库处理完request之后才能继续运行

- 回到异步的情况，如果主线程不关心数据库查询的情况，数据库查询完毕后自行处理接下来的步骤DEF,此时可以通过回调函数的机制实现
```c++
	void handle_DEF_AFTER_DBREQUEST()
	{
		D;
		E;
		F;
	}

```
这样住线程在发送数据库查询请求的同时将该函数一并当做参数传递过去着：
```c++
DB_query（request,handle_DEF_AFTER_DBREQUEST);
```
数据库线程处理万后直接调用回调函数即可。这里也可以看出来，使用回调函数实现了功能上的解耦
`即数据库线程不需要关心DB_request之后的行为，而如果需要在数据库线程实现这些行为，只需要将行为的函数作为参数传递进来，然后在数据库线程中找寻时机调用，具体函数实现的内容，在传入方定义`
- 如果主线程关心数据库操作的结果，数据库需要将查询结果利用通知机制发送给主线程，主线程在接收到消息后继续处理上一个任务的后半阶段




